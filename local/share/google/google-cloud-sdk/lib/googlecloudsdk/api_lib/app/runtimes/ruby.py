# Copyright 2015 Google Inc. All Rights Reserved.

"""Fingerprinting code for the Ruby runtime."""

import os
import re
import subprocess
import textwrap

from googlecloudsdk.api_lib.app.ext_runtimes import fingerprinting
from googlecloudsdk.api_lib.app.images import config
from googlecloudsdk.core import exceptions
from googlecloudsdk.core import log
from googlecloudsdk.core.console import console_io

# Keep these up to date. You can find the latest versions by visiting
# rubygems.org and searching for "bundler" and for "foreman".
# Checking about once every month or two should be sufficient.
# (Last checked 2015.10.20.)
BUNDLER_VERSION = '1.10.6'
FOREMAN_VERSION = '0.78.0'

# Mapping from Gemfile versions to rbenv versions with patchlevel.
# Keep this up to date. The canonical version list can be found at
# https://github.com/sstephenson/ruby-build/tree/master/share/ruby-build
# Find the highest patchlevel for each version. (At this point, we expect
# only 2.0.0 to need updating, since earlier versions are end-of-lifed, and
# later versions don't seem to be using patchlevels.)
# Checking about once a quarter should be sufficient.
# (Last checked 2015.10.20.)
RUBY_VERSION_MAP = {
    '1.8.6': '1.8.6-p420',
    '1.8.7': '1.8.7-p375',
    '1.9.1': '1.9.1-p430',
    '1.9.2': '1.9.2-p330',
    '1.9.3': '1.9.3-p551',
    '2.0.0': '2.0.0-p647'
}

# Mapping from gems to libraries they expect.
# We should add to this list as we find more common cases.
GEM_PACKAGES = {
    'rgeo': ['libgeos-dev', 'libproj-dev']
}

APP_YAML_CONTENTS = textwrap.dedent("""\
    runtime: {runtime}
    vm: true
    api_version: 1
    entrypoint: {entrypoint}
    """)
DOCKERIGNORE_CONTENTS = textwrap.dedent("""\
    .dockerignore
    Dockerfile
    .git
    .hg
    .svn
    """)

DOCKERFILE_HEADER = textwrap.dedent("""\
    # This Dockerfile for a Ruby application was generated by gcloud.

    # The base Dockerfile installs:
    # * A number of packages needed by the Ruby runtime and by gems
    #   commonly used in Ruby web apps (such as libsqlite3)
    # * A recent version of NodeJS
    # * A recent version of the standard Ruby runtime to use by default
    # * The bundler and foreman gems
    FROM gcr.io/google_appengine/ruby
    """)
DOCKERFILE_DEFAULT_INTERPRETER = textwrap.dedent("""\
    # This Dockerfile uses the default Ruby interpreter installed and
    # specified by the base image.
    # If you want to use a specific ruby interpreter, provide a
    # .ruby-version file, then delete this Dockerfile and re-run
    # "gcloud app gen-config" to recreate it.
    """)
DOCKERFILE_CUSTOM_INTERPRETER = textwrap.dedent("""\
    # Install ruby {{0}} if not already preinstalled by the base image
    RUN rbenv install -s {{0}} && \\
        rbenv global {{0}} && \\
        gem install -q --no-rdoc --no-ri bundler --version {0} && \\
        gem install -q --no-rdoc --no-ri foreman --version {1}
    ENV RBENV_VERSION {{0}}
    """.format(BUNDLER_VERSION, FOREMAN_VERSION))
DOCKERFILE_MORE_PACKAGES = textwrap.dedent("""\
    # Install additional package dependencies needed by installed gems.
    # Feel free to add any more needed by your gems.
    RUN apt-get update -y && \\
        apt-get install -y -q --no-install-recommends \\
            {0} \\
        && apt-get clean && rm /var/lib/apt/lists/*_*
    """)
DOCKERFILE_NO_MORE_PACKAGES = textwrap.dedent("""\
    # If you need to install any additional packages needed by your gems,
    # insert an "apt-get update" and "apt-get install" here.
    """)
DOCKERFILE_GEM_INSTALL = textwrap.dedent("""\
    # Install required gems.
    COPY Gemfile Gemfile.lock /app/
    RUN bundle install && rbenv rehash
    """)
DOCKERFILE_ENTRYPOINT = textwrap.dedent("""\
    # Start application on port 8080.
    COPY . /app/
    ENTRYPOINT {0}
    """)

ENTRYPOINT_FOREMAN = 'foreman start web -p 8080'
ENTRYPOINT_PUMA = 'bundle exec puma -p 8080 -e production'
ENTRYPOINT_UNICORN = 'bundle exec unicorn -p 8080 -E production'
ENTRYPOINT_RACKUP = 'bundle exec rackup -p 8080 -E production /app/config.ru'


class RubyConfigurator(fingerprinting.Configurator):
  """Generates configuration for a Ruby app."""

  def __init__(self, path, params, ruby_version, entrypoint, packages):
    """Constructor.

    Args:
      path: (str) Root path of the source tree.
      params: (fingerprinting.Params) Parameters passed through to the
        fingerprinters.
      ruby_version: (str) The ruby interpreter in rbenv format
      entrypoint: (str) The entrypoint command
      packages: ([str, ...]) A set of packages to install
    """

    self.root = path
    self.params = params
    self.ruby_version = ruby_version
    self.entrypoint = entrypoint
    self.packages = packages

    # Write messages to the console or to the log depending on whether we're
    # doing a "deploy."
    if params.deploy:
      self.notify = log.info
    else:
      self.notify = log.status.Print

  def GenerateConfigs(self):
    """Generates all config files for the module.

    Returns:
      (fingerprinting.Cleaner) A cleaner populated with the generated files
    """

    cleaner = fingerprinting.Cleaner()

    if not self.params.deploy:
      self._GenerateAppYaml(cleaner)
    if self.params.custom or self.params.deploy:
      self._GenerateDockerfile(cleaner)
      self._GenerateDockerignore(cleaner)

    if not cleaner.HasFiles():
      self.notify('All config files already exist, not generating anything.')

    return cleaner

  def _GenerateAppYaml(self, cleaner):
    """Generates an app.yaml file appropriate to this application.

    Args:
      cleaner: (fingerprinting.Cleaner) A cleaner to populate
    """
    app_yaml = os.path.join(self.root, 'app.yaml')
    if not os.path.exists(app_yaml):
      self.notify('Saving [app.yaml] to [{0}].'.format(self.root))
      runtime = 'custom' if self.params.custom else 'ruby'
      with open(app_yaml, 'w') as f:
        f.write(APP_YAML_CONTENTS.format(runtime=runtime,
                                         entrypoint=self.entrypoint))
      cleaner.Add(app_yaml)

  def _GenerateDockerfile(self, cleaner):
    """Generates a Dockerfile appropriate to this application.

    Args:
      cleaner: (fingerprinting.Cleaner) A cleaner to populate
    """
    dockerfile = os.path.join(self.root, config.DOCKERFILE)
    if not os.path.exists(dockerfile):
      self.notify('Saving [{0}] to [{0}].'.format(config.DOCKERFILE, self.root))

      dockerfile_content = [DOCKERFILE_HEADER]
      if self.ruby_version:
        dockerfile_content.append(
            DOCKERFILE_CUSTOM_INTERPRETER.format(self.ruby_version))
      else:
        dockerfile_content.append(DOCKERFILE_DEFAULT_INTERPRETER)
      if self.packages:
        dockerfile_content.append(
            DOCKERFILE_MORE_PACKAGES.format(' '.join(self.packages)))
      else:
        dockerfile_content.append(DOCKERFILE_NO_MORE_PACKAGES)
      dockerfile_content.append(DOCKERFILE_GEM_INSTALL)
      dockerfile_content.append(
          DOCKERFILE_ENTRYPOINT.format(self.entrypoint))

      with open(dockerfile, 'a') as f:
        f.write('\n'.join(dockerfile_content))

      cleaner.Add(dockerfile)

  def _GenerateDockerignore(self, cleaner):
    """Generates a .dockerignore file appropriate to this application.

    Args:
      cleaner: (fingerprinting.Cleaner) A cleaner to populate
    """
    dockerignore = os.path.join(self.root, '.dockerignore')
    if not os.path.exists(dockerignore):
      self.notify('Saving [.dockerignore] to [{0}].'.format(self.root))
      with open(dockerignore, 'w') as f:
        f.write(DOCKERIGNORE_CONTENTS)
      cleaner.Add(dockerignore)


def Fingerprint(path, params):
  """Check for a Ruby app.

  Args:
    path: (str) Application path.
    params: (fingerprinting.Params) Parameters passed through to the
      fingerprinters.

  Returns:
    (RubyConfigurator or None) Returns a configurator if the path contains a
    Ruby app, or None if not.
  """
  appinfo = params.appinfo
  entrypoint = None
  is_explicit_runtime = False
  if appinfo:
    if appinfo.GetEffectiveRuntime() != 'ruby':
      return None
    is_explicit_runtime = True

    if appinfo.entrypoint:
      entrypoint = appinfo.entrypoint

  log.info('Checking for Ruby.')

  gemfile_path = os.path.join(path, 'Gemfile')
  if not os.path.isfile(gemfile_path):
    if is_explicit_runtime:
      raise exceptions.Error('Gemfile required for Ruby runtime')
    else:
      return None

  _CheckFiles(path)

  gems = _DetectGems()
  ruby_version = _DetectRubyInterpreter(path)
  packages = _DetectNeededPackages(gems)

  if not entrypoint:
    default_entrypoint = _DetectDefaultEntrypoint(path, gems)
    entrypoint = _ChooseEntrypoint(default_entrypoint, appinfo)
    if not entrypoint:
      return None

  return RubyConfigurator(path, params, ruby_version, entrypoint,
                          packages)


def _CheckFiles(path):
  """Runs some sanity checks on the application.

  Args:
    path: (str) Application path.

  Raises:
    exceptions.Error: The application is recognized as a Ruby app but
    malformed in some way.
  """
  gemfile_lock_path = os.path.join(path, 'Gemfile.lock')
  if not os.path.isfile(gemfile_lock_path):
    raise exceptions.Error('Gemfile present but Gemfile.lock not found.')

  if not _SubprocessSucceeds('bundle check'):
    raise exceptions.Error('Your bundle is not up-to-date. '
                           "Install missing gems with 'bundle install'.")

  # TODO(dazuma): Check that the Gemfile.lock is up to date


def _DetectRubyInterpreter(path):
  """Determines the ruby interpreter and version expected by this application.

  Args:
    path: (str) Application path.

  Returns:
    (str) The interpreter version in rbenv (.ruby-version) format
  """
  ruby_info = _RunSubprocess('bundle platform --ruby')
  if not re.match('^No ', ruby_info):
    match = re.match(r'^ruby (\d+\.\d+(\.\d+)?)', ruby_info)
    if match:
      ruby_version = match.group(1)
      ruby_version = RUBY_VERSION_MAP.get(ruby_version, ruby_version)
      log.info(
          'Using MRI {0} as requested in the Gemfile.'.format(ruby_version))
      return ruby_version
    # TODO(dazuma): Identify other interpreters
    log.warning('Unrecognized platform in Gemfile: [{0}]'.format(ruby_info))

  ruby_version = _ReadFile(path, '.ruby-version')
  if ruby_version:
    ruby_version = ruby_version.strip()
    log.info(
        'Using ruby {0} as requested in the .ruby-version'.format(ruby_version))
    return ruby_version

  # Default to the latest MRI.
  log.warning('No ruby version specified. Using a default. '
              'We recommend that you specify a ruby interpreter to use, '
              'either by creating a .ruby-version file or by adding a '
              '"ruby" declaration to your Gemfile.')
  return None


def _DetectGems():
  """Returns a list of gems requested by this application.

  Returns:
    ([str, ...]) A list of gem names.
  """
  gems = []
  for line in _RunSubprocess('bundle list').splitlines():
    match = re.match(r'\s*\*\s+(\S+)\s+\(', line)
    if match:
      gems.append(match.group(1))
  return gems


def _DetectDefaultEntrypoint(path, gems):
  """Returns the app server expected by this application.

  Args:
    path: (str) Application path.
    gems: ([str, ...]) A list of gems used by this application.

  Returns:
    (str) The default entrypoint command.
  """
  procfile_path = os.path.join(path, 'Procfile')
  if os.path.isfile(procfile_path):
    return ENTRYPOINT_FOREMAN

  if 'puma' in gems:
    return ENTRYPOINT_PUMA
  elif 'unicorn' in gems:
    return ENTRYPOINT_UNICORN

  return ENTRYPOINT_RACKUP


def _ChooseEntrypoint(default_entrypoint, appinfo):
  """Prompt the user for an entrypoint.

  Args:
    default_entrypoint: (str) Default entrypoint determined from the app.
    appinfo: (apphosting.api.appinfo.AppInfoExternal or None) The parsed
      app.yaml file for the module if it exists.

  Returns:
    (str) The actual entrypoint to use.
  """
  if console_io.IsInteractive():
    prompt = ('Please enter the command to run this ruby app in production:\n'
              '[ {0} ] ')
    entrypoint = console_io.PromptResponse(prompt.format(default_entrypoint))
    entrypoint = entrypoint.strip()
    if not entrypoint:
      entrypoint = default_entrypoint
    if appinfo:
      # We've got an entrypoint and the user had an app.yaml that didn't
      # specify it.
      # TODO(mmuller): Offer to edit the user's app.yaml
      msg = ('To avoid being asked for an entrypoint in the future, please '
             'add it to your app.yaml. e.g.\n'
             '  entrypoint: {0}')
      log.status.Print(msg.format(entrypoint))
    return entrypoint
  else:
    msg = ('Using a default entrypoint of [{0}]. If this is incorrect, please '
           'create an app.yaml file with an "entrypoint" field specifying the '
           'command to run the app in production.')
    log.info(msg.format(default_entrypoint))
    return default_entrypoint


def _DetectNeededPackages(gems):
  """Determines additional apt-get packages required by the given gems.

  Args:
    gems: ([str, ...]) A list of gems used by this application.

  Returns:
    ([str, ...]) A sorted list of strings indicating packages to install
  """
  package_set = set()
  for gem in gems:
    if gem in GEM_PACKAGES:
      package_set.update(GEM_PACKAGES[gem])
  packages = list(package_set)
  packages.sort()
  return packages


def _RunSubprocess(cmd):
  p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
  if p.wait() != 0:
    raise exceptions.Error('Unable to run script: [{0}]'.format(cmd))
  return p.stdout.read()


def _SubprocessSucceeds(cmd):
  p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
  return p.wait() == 0


def _ReadFile(root, filename, required=False):
  path = os.path.join(root, filename)
  if not os.path.isfile(path):
    if required:
      raise exceptions.Error(
          'Could not find required file: [{0}]'.format(filename))
    return None
  with open(path) as f:
    return f.read()

